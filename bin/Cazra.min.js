/*! Cazra 2015-07-04 */
/**
 * Declaration of the Cazra namespace.
 * Requires Underscore JS
 */
Cazra = {
    version: '0.1.0'
};

/**
 * A handy, simnple function for debugging callbacks. It prints any arguments
 * given to it to the console.
 */
function printArgs() {
    console.log(arguments);
};

/**
 * Safely invokes a function. No effect if func is not a function or is undefined.
 * @param {function} func   The function to invoke.
 * @param {Object} scope    The context the function is invoked upon.
 * @param {any[]} args      The arguments.
 */
_.callback = _.callback || function(func, scope, args) {
    if(_.isFunction(func))
        func.apply(scope, args);
};

/**
 * Define console if it doesn't exist.
 */
try {
    console;
}
catch(err) {
    console = {
        asset: _.noop,
        count: _.noop,
        dir: _.noop,
        error: _.noop,
        group: _.noop,
        groupCollapsed: _.noop,
        groupEnd: _.noop,
        info: _.noop,
        log: _.noop,
        table: _.noop,
        time: _.noop,
        timeEnd: _.noop,
        trace: _.noop,
        warn: _.noop
    };
}

Cazra.Ajax = (function() {

    var impl = {

        _initRequestListeners: function(xhr, options) {
            xhr.addEventListener('progress', function(evt) {
                console.log('AjaxProgressEvent:', evt, xhr);

                var progress;
                if(evt.lengthComputable)
                    progress = { // TODO: Create a 'Progress' object to pass to the callback.
                        alpha: evt.loaded/evt.total,
                        loaded: evt.loaded,
                        total: evt.total
                    };

                _.callback(options.progress, options.scope, [progress, evt]);
            });


            xhr.addEventListener('error', function(evt) {
                console.error('AjaxErrorEvent:', evt);

                var status = xhr.status;
                var message = xhr.statusText;

                _.callback(options.failure, options.scope, [new Cazra.Error('AjaxError', status + ' ' + message)]);
            });


            xhr.addEventListener('abort', function(evt) {
                console.warn('AjaxAbortEvent:', evt);
                _.callback(options.failure, options.scope, [new Cazra.Error('AjaxAbortError', 'The AJAX request was aborted.')]);
            });


            xhr.addEventListener('timeout', function(evt) {
                console.error('AjaxTimeoutEvent:', evt, xhr);
                _.callback(options.failure, options.scope, [new Cazra.Error('AjaxTimeoutError', 'The AJAX request timed out.')]);
            });


            xhr.addEventListener('load', function(evt) {
                console.log('AjaxLoadEvent:', evt);

                if(xhr.status == 200)
                    _.callback(options.success, options.scope, [xhr]);
                else
                    _.callback(options.failure, options.failure, [new Cazra.Error('AjaxError', status + ' ' + message)]);
            });
        },

        /**
         * Makes an HTTP request using AJAX.
         * @param  {Object} options
         *         success: function(xhr: XMLHttpRequest)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {XmlHttpRequest} The HTTP request object used to make the
         *                              AJAX call.
         */
        request: function(options) {
            var xhr = new XMLHttpRequest();

            this._initRequestListeners(xhr, options);

            xhr.open(options.method, options.url, true, options.user, options.password);

            // Set up the request headers.
            _.each(options.headers, function(value, header) {
                xhr.setRequestHeader(header, value);
            });
            xhr.withCredentials = options.withCredentials;
            xhr.timeout = options.timeout;

            // Send the AJAX request.
            xhr.send(options.content);
            return xhr;
        }
    };

    return {

      /**
       * Makes an HTTP request using AJAX.
       * @param  {Object} options
       *         success: function(xhr: XMLHttpRequest)
       *         failure: function(error: Cazra.Error)
       *         scope: Object
       * @return {XmlHttpRequest} The HTTP request object used to make the
       *                              AJAX call.
       */
        request: function(options) {
            return impl.request(options);
        }
    };

})();

/**
 * A dictionary of words and their definitions.
 * @param {String} srcUrl
 *        The URL to load the dictionary data from. This text file is just
 *        a stringified JSON object of word:definition pairs.
 */
Cazra.Dictionary = function(srcUrl) {
    this._srcUrl = srcUrl;
    this._isLoaded = false;
    this._dictionary = {};
};

_.extend(Cazra.Dictionary.prototype, {
    /**
     * Gets the definition of a word.
     * This method is asynchronous iff options is provided.
     * @param {String} word   The word we want the definition of.
     * @param {Object} [options]
     *        success: function(definition: String)
     *        failure: function(error: Cazra.Error)
     *        scope: Object
     * @return {String} The definition.
     */
    getDefinition: function(word, options) {
        if(options) {
            this.load({
                success: function() {
                    var definition = this.getDefinition(word);
                    _.callback(options.success, options.scope, [defintion]);
                },
                failure: function(err) {
                    _.callback(options.failure, options.scope, [err]);
                },
                scope: this
            });
        }
        else
            return this._dictionary[word.toLowerCase()];
    },


    /**
     * Gets the number of words in the dictionary.
     * This method is asynchronous iff options is provided.
     * @param  {Object} [options]
     *         success: function(size: int)
     *         failure: function(error: Cazra.Error)
     * @return {int}
     */
    getSize: function(options) {
        if(options) {
            this.load({
                success: function() {
                    var size = this.getSize();
                    _.callback(options.success, options.scope, [size]);
                },
                failure: function(error) {
                    _.callback(options.failure, options.scope, [error]);
                },
                scope: this
            });
        }
        else
            return this.getWords().length;
    },


    /**
     * Gets a list of words from this dictionary passing some filter function.
     * This method is asynchronous iff options is provided.
     * @param  {function(word: String, definition: String) : Boolean} [filter]
     *         Returns true for the word iff it should be kept in the result list.
     *         If not provided, all words will be returned.
     *
     * @param  {Object} [options]
     *         success: function(words: String[])
     *         failure: function(error: Cazra.Error)
     * @return {String[]}
     */
    getWords: function(filter, options) {
        if(!filter)
            filter = function() {
                return true;
            };

        if(options) {
            this.load({
                success: function() {
                    var result = this.getWords(filter);
                    _.callback(options.success, options.scope, [result]);
                },
                failure: function(error) {
                    _.callback(options.failure, options.scope, [error]);
                },
                scope: this
            });
        }
        else {
            var result = [];

            _.each(this._dictionary, function(definition, word) {
                if(filter(word, definition))
                    result.push(word);
            }, this);

            return result;
        }

    },


    /**
     * Checks whether some word is in the dictionary.
     * This method is asynchronous iff options is provided.
     * @param  {String} word    The word to check.
     * @param  {Object} [options]
     *         success: function(result: Boolean}
     *         failure: function(error: Cazra.Error)
     *         scope: Object
     * @return {Boolean} True iff word exists in the dictionary.
     */
    isWord: function(word, options) {
        if(options) {
            this.load({
                success: function() {
                    var result = this.isWord(word);
                    _.callback(options.success, otions.scope, [result]);
                },
                failure: function(err) {
                    _.callback(options.failure, options.scope, [err]);
                },
                scope: this
            });
        }
        else
            return !!this._dictionary[word.toLowerCase()];
    },


    /**
     * Loads the dictionary from its external resource if it hasn't already
     * been loaded.
     * @param {Object} options
     *    success: function()
     *    failure: function(Cazra.Error)
     *    scope: Object
     */
    load: function(options) {
        options = options || {};

        if(this._isLoaded)
            _.callback(options.success, options.scope, []);
        else {
            Cazra.Ajax.request({
                url: this._srcUrl,
                method: 'GET',
                success: function(xhr) {
                    try {
                        var srcDict = JSON.parse(xhr.responseText);
                        this._dictionary = {};

                        _.each(srcDict, function(definition, word) {
                            this._dictionary[word.toLowerCase()] = definition;
                        }, this);

                        this._isLoaded = true;
                        _.callback(options.success, options.scope, []);
                    }
                    catch(err) {
                        _.callback(options.failure, options.scope, [new Cazra.Error('JSONError', 'Could not parse HTTP response.')]);
                    }
                },
                failure: function(err) {
                    _.callback(options.failure, options.scope, [err]);
                },
                scope: this
            });
        }
    }
});

/**
 * Encapsulates an error with type and source info.
 * @param {String} type   The type of error. Useful for type-checking errors.
 * @param {String} message  A message with a brief explanation about the error.
 * @param {Object} [source]   The object from which this error originates.
 */
Cazra.Error = function(type, message, source) {
    this.type = type;
    this.message = message;
    this.source = source;

    try {
        throw new Error();
    }
    catch(err) {
        this.stackTrace = err.stack;
    }
};

Cazra.Error.prototype = {
    isError: true,

    /**
     * Returns the error's message.
     * @return {String}
     */
    getMessage: function() {
        return this.message;
    },

    getSource: function() {
        return this.source;
    },

    getStackTrace: function() {
        return this.stackTrace;
    },

    getType: function() {
        return this.type;
    }
};

/**
 * A small API for geolocation of the user's device.
 * Once the Geolocation permissions are ready, this singleton's
 * operations can be used either synchronously or asynchronously.
 */
Cazra.Geolocation = (function() {
    var impl = {

        _lastPosition: {},
        _lastTimestamp: undefined,
        _isWatched: false,

        /**
         * Retrieves the accuracy of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(accuracy: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getAccuracy: function(options) {
            return this._getCoordsProperty('accuracy', options);
        },

        /**
         * Retrieves the altitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(altitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getAltitude: function(options) {
            return this._getCoordsProperty('altitude', options);
        },

        /**
         * Retrieves the accuracy of the user's current altitude.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(altitudeAccuracy: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getAltitudeAccuracy: function(options) {
            return this._getCoordsProperty('altitudeAccuracy', options);
        },

        /**
         * Retrieves some property of the user's current coordinates.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(property: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        _getCoordsProperty: function(propName, options) {
            if(_.isObject(options))
                this.getPosition({
                    success: function(position) {
                        _.callback(options.success, options.scope, [position.coords[propName]]);
                    },
                    failure: function(error) {
                        _.callback(options.failure, options.scope, [error]);
                    }
                });
            else
                return this.getPosition().coords[propName];
        },

        /**
         * Retrieves the heading of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(heading: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getHeading: function(options) {
            return this._getCoordsProperty('heading', options);
        },

        /**
         * Returns the last timestamp for when the position data was updated.
         * @return {number} The timestamp
         */
        getLastTimestamp: function() {
            return this._lastTimestamp;
        },

        /**
         * Retrieves the latitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(latitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getLatitude: function(options) {
            return this._getCoordsProperty('latitude', options);
        },

        /**
         * Retrieves the longitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(longitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getLongitude: function(options) {
            return this._getCoordsProperty('longitude', options);
        },

        /**
         * Retrieves the speed of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(speed: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getSpeed: function(options) {
            return this._getCoordsProperty('speed', options);
        },

        /**
         * Retrieves the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(position: Position)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getPosition: function(options) {
            if(!_.isObject(options)) {
                if(this._isWatched)
                    return this._lastPosition;
                else
                    throw new Cazra.Error('PositionUnavailableError', 'Could not get updated position data.');
            }
            else if(this._isWatched)
                _.callback(options.success, options.scope, [this._lastPosition]);
            else if(!this._watchId) {
                this._watchId = navigator.geolocation.watchPosition(
                    function(position) { // Success callback.
                        this._lastPosition = position;
                        this._lastTimestamp = position.timestamp;

                        if(!this._isWatched) {
                            this._isWatched = true;
                            _.callback(options.success, options.scope, [position]);
                        }
                    }.bind(this),
                    function(positionError) { // Error callback.
                        var code = positionError.code;
                        var type;

                        if(code == 1)
                            type = 'PermissionError';
                        else if(code == 2)
                            type = 'PositionUnavailableError';
                        else if(code == 3)
                            type = 'TimeoutError';
                        else
                            type = 'UnknownError';

                        this._watchId = undefined;

                        var error = new Cazra.Error(type, positionError.message);
                        _.callback(options.failure, options.scope, [error]);

                    },
                    options.positionOptions
                );
            }
            else
                _.callback(options.failure, options.scope, [new Cazra.Error('NotReadyError', 'Geolocation is not ready.')]);
        },


        start: function(options) {
            // TODO
        },

        stop: function() {

        }
    };

    return {
      /**
       * Retrieves the accuracy of the user's current position.
       * The operation will be asynchronous iff the options parameter is provided.
       * @param  {Object} [options]
       *         success: function(accuracy: number)
       *         failure: function(error: Cazra.Error)
       *         scope: Object
       * @return {Position}
       */
        getAccuracy: function(options) {
            return impl.getAccuracy(options);
        },

        /**
         * Retrieves the altitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(altitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getAltitude: function(options) {
            return impl.getAltitude(options);
        },

        /**
         * Retrieves the accuracy of the user's current altitude.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(altitudeAccuracy: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getAltitudeAccuracy: function(options) {
            return impl.getAltitudeAccuracy(options);
        },

        /**
         * Retrieves the heading of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(heading: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getHeading: function(options) {
            return impl.getHeading(options);
        },

        /**
         * Returns the last timestamp for when the position data was updated.
         * @return {number} The timestamp
         */
        getLastTimestamp: function() {
            return impl.getLastTimestamp();
        },

        /**
         * Retrieves the latitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(latitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getLatitude: function(options) {
            return impl.getLatitude(options);
        },

        /**
         * Retrieves the longitude of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(longitude: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getLongitude: function(options) {
            return impl.getLongitude(options);
        },

        /**
         * Retrieves the speed of the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(speed: number)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getSpeed: function(options) {
            return impl.getSpeed(options);
        },

        /**
         * Retrieves the user's current position.
         * The operation will be asynchronous iff the options parameter is provided.
         * @param  {Object} [options]
         *         success: function(position: Position)
         *         failure: function(error: Cazra.Error)
         *         scope: Object
         * @return {Position}
         */
        getPosition: function(options) {
            return impl.getPosition(options);
        }
    };
})();

/**
 * A small API around the Notification interface for automatically and
 * asynchronously handling permissions.
 * @requires Cazra, Cazra.Error
 */
Cazra.Notifications = (function() {
    var impl = {

        /**
         * Attempts to display a notification.
         * @param {String} title      The title text of the notification.
         * @param {Object} options    All options that can be passed into
         *      Notification's options parameter, plus the following additional
         *      options:
         *
         *    success: function(notification: Notification)
         *        The success callback, with the Notification that was created.
         *
         *    failure: function(error: Cazra.Error)
         *        The failure callback, with an error providing the reason for it.
         *
         *    scope: Object
         *        The scope of the callbacks.
         */
        show: function(title, options) {
            options = options || {};
            if(Notification.permission == 'granted')
                this._show(title, options);
            else if(Notification.permission != 'denied')
                Notification.requestPermission(function(result) {
                    if(result == 'denied')
                        _.callback(options.failure, options.scope, [new Cazra.Error('PermissionError', 'Permission Denied.')]);
                    else
                        this._show(title, options);
                }.bind(this));
            else
                _.callback(options.failure, options.scope, [new Cazra.Error('PermissionError', 'Permission Denied.')]);
        },

        /**
         * @private
         * Helper method for show().
         */
        _show: function(title, options) {
            var noti = new Notification(title, {
                dir: options.dir,
                lang: options.lang,
                body: options.body,
                tag: options.tag,
                icon: options.icon,
                data: options.data,
                sound: options.sound,
                vibrate: options.vibrate,
                renotify: options.renotify,
                silent: options.silent,
                noscreen: options.noscreen,
                sticky: options.sticky
            });

            _.callback(options.success, options.scope, [noti]);
        }
    };

    return {
        show: function(title, options) {
            return impl.show(title, options);
        }
    };
})();

/**
 * A conucurrency construct implementing an asynchronous semaphore.
 * This allows a function to be invoked only after a group of other
 * potentially asynchronous functions have resolved.
 * See: https://en.wikipedia.org/wiki/Asynchronous_semaphore
 * @param  {int}   initLock     The initial value of the Asem's lock.
 * @param  {Function} callback  The function invoked when signal causes the lock to become 0.
 * @param  {[type]}   scope     The scope of the callback.
 */
Cazra.Asem = function(initLock, callback, scope) {
    if(!initLock)
        initLock = 0;

    this._lock = initLock;
    this._callback = callback;
    this._scope = scope;
    this._isFired = false;

    if(Cazra.Asem.debug) {
        Cazra.Asem.assignId(this);

        console.info('Created Asem: ', this);
        Cazra.Asem.debug._activeAsems.push(this);
    }
};

_.extend(Cazra.Asem.prototype, {

    /**
     * Returns the current lock count of the Asem.
     * @return {int}
     */
    getLockCount: function() {
        return this._lock;
    },

    /**
     * Decrements the lock. If the lock becomes zero, the callback is invoked.
     */
    signal: function() {
        this._lock--;
        if(this._lock == 0) {
            if(this._isFired)
                throw new Cazra.Error('Asem');
            else {
                this._isFired = true;
                _.callback(this._callback, this._scope, []);
            }
        }
        else if(this._lock < 0) {
            throw new Cazra.Error('AsemError', 'Cannot signal asynchronous semaphore with a lock value that is already 0.');
        }
    },

    /**
     * Returns a function which invokes this Asem's signal.
     * @return {function()}
     */
    toFn: function() {
        var me = this;
        return function() {
            me.signal();
        };
    },

    toString: function() {

    },

    /**
     * Increments the lock.
     */
    wait: function() {
        if(this._isFired)
            throw new Cazra.Error('AsemError', 'Cannot wait asynchronous semaphore that has already been fired.');
        this._lock++;
    }
});

/**
 * Static properties.
 */
_.extend(Cazra.Asem, {
    /**
     * Set this to true to enable debugging of Asems.
     * With debugging turned on, you can keep track of Asems that haven't been
     * fired yet.
     * Also, with debug on, messages will be printed to the console when Asems
     * are created, waited, signaled, and fired.
     * @type {Boolean}
     */
    debug: false,

    _nextId: 0,
    _activeAsems: [],



    /**
     * @private
     * @param  {Cazra.Asem} asem
     */
    _debugCreate: function(asem) {
        if(this.debug) {
            asem._id = this._nextId;
            this._nextId++;

            this._activeAsems.push(asem);

            console.info('Created Asem: ', asem);
        }
    },

    /**
     * @private
     * @param  {Cazra.Asem} asem
     */
    _debugFire: function(asem) {
        if(this.debug) {
            var index = this._activeAsems.indexOf(asem);
            this._activeAsems.splice(index, 1);

            console.info('Fired Asem: ', asem);
        }
    },

    /**
     * @private
     * @param  {Cazra.Asem} asem
     */
    _debugSignal: function(asem) {
        if(this._debug) {
            console.info('Signaled Asem: ', asem, asem._lock);
        }
    },

    /**
     * @private
     * @param  {Cazra.Asem} asem
     */
    _debugWait: function(asem) {
        if(this._debug)
            console.info('Waited Asem: ', asem, asem._lock);
    },


    /**
     * Returns the list of Asems that haven't been fired yet.
     * @return {[type]} [description]
     */
    getUnfiredAsems: function() {
        return _.clone(this._activeAsems);
    }
});
